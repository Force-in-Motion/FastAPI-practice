from fastapi import FastAPI, status, Body

app = FastAPI()


messages_db = {0: "First post in FastAPI"}

# TODO  Один из параметров декоратора (get, post, put, delete, patch ....) status_code, он принимает значение возвращающее статус ответа.
#       В нашем случае нам необходимо установить код 201, означающий успешное создание.


# TODO  GET — это метод для чтения данных с сайта. Например, для доступа к указанной странице. Он говорит серверу, что клиент хочет прочитать указанный документ.
#       Метод мы объявляем с помощью декоратора @app.get. Как мы уже знаем из прошлого шага, первым параметром(path) мы передаем параметры пути.
#       Также мы можем передавать ему код состояния ответа(status_code), теги, описания и другие параметры.


@app.get("/")
async def get_all_messages() -> dict:
    """
    Возвращает все сообщения, сохраненные в базе данных
    """
    return {"status": "ok", "messages": messages_db}


@app.get("/message/{message_id}")
async def get_message(message_id: int) -> dict[str, str]:
    """
    Возвращает сообщение с полученным id если такое есть в базе данных
    """
    return {"status": "ok", "message": messages_db.get(message_id)}


# TODO  Использование метода GET для взаимодействия между клиентом и сервером через HTTP имеет определенные недостатки.
#       Прежде всего, это не очень безопасно, так как URL-адрес вместе с данными параметров виден в адресной строке браузера.
#       Во-вторых, существует ограничение на то, сколько данных может быть отправлено на сервер вместе с запросом GET.

# TODO  Кроме того, отправляемые данные должны быть представлены только символами ASCII.
#       Это означает, что любые двоичные данные, такие как изображение, не могут быть частью запроса GET.
#       Чтобы отправить запрос на создание новой записи, протокол HTTP требует использования метода POST.
#       И данные, необходимые для создания новой записи, упаковываются в тело запроса POST


@app.post("/message", status_code=status.HTTP_201_CREATED)
async def create_message(message: str = Body()) -> dict[str, str]:
    """
    Добавляет новое сообщение в БД, если словарь пуст то добавляет первое сообщение с ключом (id) 0
    В противном случае находит максимальный ключ (id) и создает новый ключ, увеличив его на 1 и присваивает ему полученное значение
    """
    if not messages_db:
        messages_db[0] = message

    index = int(max(messages_db, key=int)) + 1

    messages_db[index] = message

    return {"message": "Message created!"}


# TODO  PUT
# TODO  В REST (Representational State Transfer) архитектуре PUT-запросы используются для обновления или замены существующего ресурса.
#       Это один из основных HTTP-методов, и его использование в REST API следует принципам RESTful дизайна.

# TODO  Ключевые аспекты PUT-запросов в REST:
#       Идентификация данных: PUT-запрос всегда обращается к конкретным данным, идентифицируемым их URI (Uniform Resource Identifier).
#       URI указывает на местоположение ресурса на сервере.

# TODO  Полная замена: В идеале, PUT-запрос должен заменять все конкретные данные полностью. Клиент отправляет полное представление данных в теле запроса.
#       Сервер затем заменяет существующий ресурс на новый, предоставленный клиентом. Это ключевое отличие от PATCH-запроса, который используется для частичного обновления.

# TODO  Идемпотентность: PUT-запросы идемпотентны. Это означает, что повторное выполнение того же PUT-запроса с теми же данными приведёт к тому же результату.
#       Сервер должен обрабатывать повторные запросы как однократные.

# TODO  Состояние сервера: PUT-запрос изменяет состояние сервера.
#       После успешного выполнения PUT-запроса состояние данных на сервере будет отражать данные, предоставленные клиентом.


@app.put("/message/{message_id}")
async def update_message(message_id: int, message: str = Body()) -> str:
    """
    Получает новое сообщение в теле запроса и id сообщения как qwery параметр,
    которое хранится в базе, присваивает полученному id (ключ в словаре) новое полученное сообщение.
    """
    messages_db[message_id] = message
    return "Message updated!"


# TODO  Запрос DELETE - это метод, используемый в протоколе передачи гипертекста (HTTP) для запроса на удаление или удаление ресурса на сервере.
#       Когда клиент отправляет запрос DELETE на сервер, он просит удалить указанный ресурс, такой как файл или запись базы данных.

# TODO  Метод является идемпотентным, что означает, что выполнение нескольких одинаковых запросов должно иметь тот же эффект, что и выполнение одного запроса.
#       Однако важно отметить, что фактическое удаление ресурса зависит от реализации и политики сервера.
#       После получения запроса DELETE, сервер обрабатывает его и удаляет указанный ресурс, если он существует, возвращая код состояния, указывающий на успех или неудачу операции.


@app.delete("/message/{message_id}")
async def delete_message(message_id: int) -> str:
    """
    Удаляет сообщение из базы данных, которое соответствует полученному id
    """
    messages_db.pop(message_id)
    return f"Message ID={message_id} deleted!"


@app.delete("/")
async def kill_message_all() -> dict[str, str]:
    """
    Полностью очищает базу данных
    """
    messages_db.clear()
    return {"status": "ok"}
